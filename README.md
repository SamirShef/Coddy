# Coddy
**Текущая версия `Coddy` - v0.5.0**

`Coddy` - универсальный, высокоуровневый, статически типизированный язык программирования, созданный с опорой на синтаксис `Python`, `C++` и других языков. `Coddy` написан на высокоуровневом языке программирования `C#` с использованием нейросети `DeepSeek`. Язык `Coddy` транслируется в `C#` для осуществления компиляции по средствам компилятора `C#`.

# Состовляющие языка:
* [Синтаксис](#синтаксис)
* [Примитивные типы](#примитивные-типы)
* [Переменные](#переменные)
* [Операторы](#операторы)
* [Блоки](#блоки)
* [Ветвление](#ветвление)
* [Циклы](#циклы)
* [Фунции](#функции)
* [Массивы](#массивы)
* [ООП (упрощённое)](#ооп-упрощённое)
* [Импорт библиотек](#импорт-библиотек)
* [Поддержка](#поддержка)

# Синтаксис
* Каждая команда должна оканчиваться специальным символом `;`
* Числовые литералы (за исключением целочисленных литералов) должны иметь суффикс `f`, `d` или `m` (в соответствии с числовым типом литерала)
> [!NOTE]
> Суффикс `f` пренадлежит числовому типу float, суффикс `d` - типу double, суффикс `m` - типу decimal.
* Дробные числовые литералы должны иметь точку для разделения целой и дробной частей
* Строковые литералы должны быть заключены в кавычки `'` или `"`
> [!IMPORTANT]
> Кавычки до и после строкового литерала должны совпадать:
> ```Coddy
> "Hello 1" // ОК
> 'Hello 2' // ОК
> "Hello 3' // ОШИБКА
> 'Hello 4" // ОШИБКА
> ```

# Примитивные типы
Примитивыне типы данных, поддерживаемые `Coddy`:
* int
* float
* double
* decimal
* string
* boolean
> [!IMPORTANT]
> Примитивыне типы данных не имеют встроенных методов и свойств.

# Переменные
Объявление переменных осуществляется с помощью ключевого слова `let`, последующим именем переменной, разделительным символом `:`, последующим типом и (при необходимости) знаком `=` и инициализирующим выражением.
> [!NOTE]
> Тип переменной и итоговый тип инициализирующего выражения должны явно или неявно совпадать (например явно совпадают `int` и `int`, неявно - `float` и `int`, потому что `int` целиком помещается в `float`, а `float` целиком в `int` не поместится, что выведет ошибку типа).
>
> Если у переменной не инициализированно значение, то ей присваивается дефолтное для данного типа значение:
> * `int` -> 0
> * `float` -> 0f
> * `double` -> 0d
> * `decimal` -> 0m
> * `string` -> ""
> * `boolean` -> false

Пример
```
let a : int;  // ОК (имеет дефолтное значение 0)
let b : int = 10;  // ОК
let c : double = 10f;  // ОК
let d : string = "Hello world!";  // ОК
let e : string = 10;  // ОШИБКА ТИПА
let f : int = 10.2f;  // ОШИБКА ТИПА
```
Переменные можно использовать в выражениях
> [!IMPORTANT]
> Тип переменной, используемой в выражении, должен явно или неявно совпадать требуемому типу выражения.
Пример
```
let a : int = 10;
let b : int = a;  // ОК
let c : string = a;  // ОШИБКА ТИПА
```

# Операторы
Операторы в `Coddy` делятся на:
* [Арифметические](#арифметические-операторы)
* [Логические](#логические-операторы)
* [Присвоения](#операторы-присвоения)
* [Тернарные](#тернарные-операторы)
> [!WARNING]
> Операторы могут быть использованы только с явно или неявно равными типами выражений. Каждый тип может быть использован только в опеределённой группе операторов, заданных языком.

### Арифметические операторы
* `+` (Плюс)
* `-` (Минус)
* `*` (Умножить)
* `/` (Разделить)
* `%` (Остаток от деления)

### Логические операторы
* `>` (Больше)
* `>=` (Больше или равно)
* `<` (Меньше)
* `<=` (Меньше или равно)
* `||` (ИЛИ)
* `&&` (И)
* `==` (Равно)
* `!=` (Не равно)
* `!` (Логическое отрицание)

### Операторы присвоения
* `=` (Равно)
* `+=` (Прибавить к текущему значению выражение)
* `-=` (Отнять от текущего значения выражение)
* `*=` (Умножить текущее значение на выражение)
* `/=` (Разделиь текущее значение на выражение)
* `%=` (Присвоить остаток от деления текущего значения к выражению)
* `++` (Инкремент/Прибавить 1)
* `--` (Декремент/Отнять 1)

### Тернарные операторы
Тернарный оператор образуется из **условного выражения**, последующих знака `?`, выражения при _истинном условном выражении_, символа `:` и выражения при _ложном условном выражении_.
> [!IMPORTANT]
> Тернарные операторы применимы только к выражениям.

Пример
```Coddy
let a : string = 1 == 1 ? "YES" : "NO";  // Сохранит значение "YES"
```

# Блоки
Блоками кода называется весь код, заключённый в фигурные скобки `{}`.

# Ветвление
Ветвление строится на двух ключевых словах: `if` ("если", требует обязательного условного выражения) и `else` ("иначе", условное выражение не указывается). Ветвление строится с помощью ключевого слова `if`, последующего условного выражения, заключённого в круглые скобки `()` и блока кода, который выполнится при _истинном_ условном выражении. После основного условного оператора может идти неосновной исключающий условный оператор `else`, который требует только последующего блока кода, который выполнится, если основное условное выражение (описанное в `if`) будет _ложным_.

Пример
```Coddy
let a : int = 10;
if (a > 10) {  // ЛОЖЬ (выполнится код в else)
  a = 0;
}
else {
  a = -1;
}
```

# Циклы
* [while](#цикл-while)
* [do/while](#цикл-dowhile)
* [for](#цикл-for)

### Цикл while
Тело цикла выполняется до тех пор, пока истино условное выражение (сначала идёт проверка на истинность условного выражения, а затем выполнение блока кода при _истинном_ условном выражении). Цикл `while` строится с помощью ключевого слова `while`, последующего условного выражения, заключённого в круглые скобки `()` и блока кода, который будет выполнятся пока _истино_ условное выражение.

Пример
```Coddy
let a : int;
while (a < 10) {
  a++;
}
```

### Цикл do/while
Тело цикла выполняется до тех пор, пока истино условное выражение (сначала выполняется тело цикла, а затем идёт проверка на истинность условного выражения. Если условное выражение истинно, то выполнение тела продолжается). Цикл `do/while` строится с помощью ключевого слова `do`, блока кода, ключевого слова `while`, последующего условного выражения, заключённого в круглые скобки `()` и символом окончания строки `;`.

Пример
```Coddy
let a : int;
do {
  a++;
} while (a < 10);
```

### Цикл for
Цикл `for` имеет свой встроенный индексатор, тело цикла выполняется до тех пор, пока истино условное выражение (сначала идёт объявление индексатора, затем проверка на истинность условного выражения. Если условное выражение _истинно_, то выполняется тело цикла, после чего индексатор меняет своё значение, в соответсвтии с заданным пользователем параметром изменения). Цикл `for` строится с помощью ключевого слова `for`, последующими свойствами цикла и блоком кода. Свойства цикла `for` строятся с помощью объявления индексатора (`<имя_индексатора> : <тип> = <выражение>`), разделительного символа `:`, условного выражения, разделительного символа `:` и параметр изменения индексатора (`<имя_индексатора> <оператор_присвоения> <выражение>`). Свойства цикла заключены в круглые скобки `()`.

Пример
```Coddy
let a : int;
for (i : int = 0 : i < 10 : i++) {
  a = i * i;
}
```

# Функции
* [void-функции (не возвращающие значений)](#свойства-void-функций)
* [type-функции (возвращающие значения)](#свойства-type-функций)
* [Встроенные](#встроенные-функции)

Функции объявляются с помощью ключевого слова `func`, последующим именем функции, аргументами функции (`<имя_аргумента> : <тип_аргумента>`), перечисленными через запятую `,`, заключенными в круглых скобках `()`, а также последующим блоком кода (void-функция). Для объявления type-функции после имени функции необходимо указать символ разделения `:`, а также тип возвращаемого значения. Для возврата значений из функции необходимо использовать оператор `return` с последующим возвращаемым выражением.
> [!IMPORTANT]
> Тип возвращаемого значения функции и тип значения, описанного после `return` должны быть явно или неявно равны.
> В void-функциях разрешено использование `return`, но при условии отсутствия возвращаемого выражения после `return`.

Вызов функции строится с помощью имени функции и последующим перечислением через запятую `,` аргументов функции (при наличии), заключенным в круглых скобках `()`.
> [!IMPORTANT]
> Типы перечисляемых аргументов и ожидаемых аргументов функции должны быть явно или неявно равны.
> Количество перечисляемых и ожидаемых аргументов должно совпадать.

### Свойства void-функций
* Не обязательно могут иметь операторы `return`
* Не могут использоваться в выражениях (только в виде отдельной команды)

Пример void-функции
```Coddy
let a : int;
func b () {  // Декларация
  a = 10;
}

b();  // Вызов
```

### Свойства type-функций
* Обязательно должны иметь операторы `return` с описываемым выражением
* Могут использоваться как в выражениях, так и в виде отдельной команды
* Должны иметь операторы `return` для каждого случая

Пример type-функции
```Coddy
func sum : int(a : int, b : int) {  // Декларация
  return a + b;
}

let a : int = sum(1, 2);  // Использование. Сохранит 3
```

> [!CAUTION]
> Транслятор из `Coddy` в `C#` автоматически генерирует метод `__Main__()`, который является точкой входа в программу. Функции на `Coddy` нельзя называть `__Main__()`, так как в таком случае после трнасляции возникнет 2 одинаковых по названию метода `__Main__()`, что приведёт к ошибке компиляции.

### Встроенные функции
* `println(message)` - функция, которая выводит любой переданный объект в консоль
* `input()` - функция, которая возвращает введённое пользователем в консоль сообщения
* `to_int(object)` - функция, которая конвертирует переданный объект в целое число
* `to_float(object)` - функция, которая конвертирует переданный объект в число с плавающей точкой
* `to_double(object)` - функция, которая конвертирует переданный объект в число с плавающей точкой двойной точности
* `to_decimal(object)` - функция, которая конвертирует переданный объект в вещественное число
* `to_string(object)` - функция, которая возвращает строковое представление переданного объекта
* `to_boolean(strBoolean)` - функция, которая возвращает конвертированное переданное строковое представление логического типа в логический тип
* `len(object)` - функция, которая возвращает длину переданного объекта (массива или строки)
* `type(object)` - функция, которая возвращает строковое представление типа переданного объекта

# Массивы
Массивы объявляются как и обычные переменные, но после типа ставятся квадратные скобки `[]`, внутри которых по желанию можно указать длину массива (по умолчанию длина равна 0). По желанию можно проинициализировать массив с помощью знака `=` и в квадратных скобках `[]` через запятую `,` указать элементы массива.

> [!IMPORTANT]
> Если Вы указали размер массива и решили проинициализировать его, то количество указанных Вами элементов должно совпадать с заданным Вами размером.

Пример
```Coddy
let array : int[];  // ОК
let array2 : int[4];  // ОК
let array3 : int[] = [1, 2, 3, 4];  // ОК
let array4 : int[4] = [1, 2, 3];  // ОШИБКА (кол-во переданных элементов не совпадает с заданным размером)
```

> [!WARNING]
> В данной версии `Coddy` нельзя указывать массивы в качестве возвращаемых значений для функций и методов. В последующих версиях разработчик это исправит.

# ООП (упрощённое)
`Coddy` поддерживает упрощённую систему ООП, а именно: [классы](#классы), [поля/методы классов](#поля-и-методы), [контекст `this`](#контекст-this), [конструкторы](#конструкторы), [создание экземпляров классов](#экземпляры), [вызов полей/методов из экземпляров](#вызовы-членов-класса), [статика](#статика).

### Классы
Классы объявляются с помощью ключевого слова `class`, последующего имени класса и блоком кода класса.

Пример
```Coddy
class Test {
  
}
```

### Поля и методы
Внутри класса могут существовать только _поля_ и _методы_, которые в совокупности называются _члены класса_. Каждый член класса имеет свой модификатор доступа `private` или `public`. Поля и методы декларируются также, как переменные и функции, но с использовнием модификатора доступа в начале.

Пример
```Coddy
class Person {
  private let age : int = 15;

  public func print {
    return println("Hello world!");
  }
}
```

### Контекст `this`
К членам данного класса внутри него самого возможно обращаться только с помощью контекста `this`. Для обращения к любому полю/методу изнутри исходного класса необходимо использовать ключевое слово `this`, оператор точка `.` и интересующий член класса.

Пример
```Coddy
class Person {
  private let age : int = 15;

  public func getAge : int() {
    return this.age;  // Контекст this
  }
}
```

### Конструкторы
Для того чтобы задать необходимые значения полям класса при создании экземпляра можно использовать **конструкторы**. Для использования конструктора необходимо использовать ключевое слово `constructor` (как отдельный член класса, но без модификатора досутпа), последующее перечисление аргументов конструктора, заключённых в круглые скобки `()` и блок конструктора.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }
}
```

> [!IMPORTANT]
> Типы перечисляемых аргументов и ожидаемых аргументов конструктора должны быть явно или неявно равны.
> Количество перечисляемых и ожидаемых аргументов должно совпадать.
> В классе возможно использовать только один конструктор.

### Экземпляры
Экземпляр класса `<класс>` - переменная, с типом `<класс>` и выражением в виде `new <класс>(<аргументы_конструктора>)`. Экземпляры классов можно создавать как в основной программе, так и внутри других классов. Экземпляры класса создаются только в том случае, если класс не является статическим.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }
}

let person : Person = new Person("Alex", 15);
```

### Вызовы членов класса
Члены класса вызываются из экземпляра с помощью оператора точка `.`. Члены класса из экземпляра можно вызвать только в том случае, если данный член помечен модификатором досутпа `public`. Вызвы можно использовать в выражениях, если итоговое полученное поле/метод можно использовать в выражениях.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }

  public func getAge : int() {
    return this.age;
  }

  public func printName() {
    println(this.name);
  }
}

let person : Person = new Person("Alex", 15);
let age : int = person.getAge();  // ОК
let name : string = person.name;  // ОШИБКА УРОВНЯ ЗАЩИТЫ
person.printName();  // ОК
```

### Статика
`Coddy` с версии **v0.3.0** поддерживает статические классы, методы и поля. Статические классы не могут иметь нестатических полей и методов, а также конструкторов. Статические методы могут существовать как любых классах, но внутри таких методов можно использовать только статические методы и поля того же класса (с помощью контекста `this`). Доступ к статическим полям и методам осуществляется с помощью имени класса, оператора точка `.` и именем члена класса.

Пример
```Coddy
static class Person {
  public static let Name : string = "Alex";
  public static func GetAge : int () {
    return 15;
  }
}

println(Person.Name);
println(Person.GetAge());
Person.Name = "Nikita";
println(Person.Name);
```

# Импорт библиотек
`Coddy` с версии **v0.4.0** поддерживает импорт библиотек. Импорт библиотек осуществляется с помощью ключевого слова include и строкового литерала пути к библиотечному файлу. Считываются только классы из библиотечного файла.
`Coddy` с версии **v0.5.0** поддерживает импорт нативных библиотек (*.dll и *.cs).

> [!IMPORTANT]
> `Coddy` поддерживает в качестве библиотечных файлов только файлы с расширением *.cd, *.dll, *.cs.

> [!CAUTION]
> Импорт нативных библиотек может работать нестабильно. `Quantum Games Studio` просит обращаться в [поддержку](#поддержка) для выявления и последующего устранения ошибок.

Пример
```Coddy
include "math.cd";

println(math.sqrt(25));  // Встроенный метод статического класса math
```

# Поддержка
`Quantum Games Studio` предоставляет возможность задавать вопросы и обращаться за просьбой об устранении ошибок в проекте `Coddy` напрямую на [почту](https://mail.google.com/mail/?view=cm&fs=1&to=coddy.project@gmail.com) или в [телеграм](https://t.me/SamirShef).

Изначальная идея к названию проекта была `Бутерброд++` (источник: [Burrittoss](https://t.me/Burrittosss)).

Язык будет дорабатываться и обрастать новыми возможностями, совсем скоро будет очередное обновление...
