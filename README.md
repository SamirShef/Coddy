# Coddy
**Текущая версия `Coddy` - v0.10.4**

`Coddy` - универсальный, высокоуровневый, статически типизированный язык программирования, созданный с опорой на синтаксис `Python`, `C++` и других языков. `Coddy` написан на высокоуровневом языке программирования `C#` с использованием нейросети `DeepSeek`. Язык `Coddy` транслируется в `C#` для осуществления компиляции по средствам компилятора `C#`. Официальный сайт проекта `Coddy` можно посетить [здесь](https://samirshef.github.io/Quantum-Games-Studio/Quantum%20Games%20Studio%20Documentations/Coddy%20Lang%20Pages/Main%20Page/html/index.html).

# Состовляющие языка:
* [Синтаксис](#синтаксис)
* [Примитивные типы](#примитивные-типы)
* [Служебные символы](#служебные-символы)
* [Переменные](#переменные)
* [Операторы](#операторы)
* [Блоки](#блоки)
* [Ветвление](#ветвление)
* [Циклы](#циклы)
* [Switch/case](#switchcase)
* [Фунции](#функции)
* [Массивы](#массивы)
* [ООП (неполное)](#ооп-неполное)
* [Константы](#константы)
* [Перечисления](#перечисления)
* [Импорт библиотек](#импорт-библиотек)
* [Импорт файлов](#импорт-файлов)
* [Лямбда-выражения](#лямбда-выражения)
* [Исключения](#исключения)
* [Generics обобщения](#generics-обобщения)
* [Поддержка](#поддержка)

# Синтаксис
* Каждая команда должна оканчиваться специальным символом `;`
* Числовые литералы (за исключением целочисленных литералов) должны иметь суффикс `f`, `d` или `m` (в соответствии с числовым типом литерала)
> [!NOTE]
> Суффикс `f` пренадлежит числовому типу float, суффикс `d` - типу double, суффикс `m` - типу decimal.
* Дробные числовые литералы должны иметь точку для разделения целой и дробной частей
* Строковые литералы должны быть заключены в кавычки `'` или `"`
> [!IMPORTANT]
> Кавычки до и после строкового литерала должны совпадать:
> ```Coddy
> "Hello 1" // ОК
> 'Hello 2' // ОК
> "Hello 3' // ОШИБКА
> 'Hello 4" // ОШИБКА
> ```

# Примитивные типы
Примитивные типы данных, поддерживаемые `Coddy`:
* int
* float
* double
* decimal
* string
* boolean
> [!IMPORTANT]
> Примитивные типы данных не имеют встроенных методов и свойств.

# Служебные символы
Служебные символы в строках записываются с помощью токена `\` и последующим кодом символа.

Служебные символы, которые поддерживает `Coddy`:
* `\\` - символ `\`
* `\t` - символ табуляции
* `\n` - символ перевода на следующую строку
* `\'` - символ `'`
* `\"` - символ `"`

# Переменные
Объявление переменных осуществляется с помощью ключевого слова `let`, последующим именем переменной, разделительным символом `:`, последующим типом и (при необходимости) знаком `=` и инициализирующим выражением.
> [!NOTE]
> Тип переменной и итоговый тип инициализирующего выражения должны явно или неявно совпадать (например явно совпадают `int` и `int`, неявно - `float` и `int`, потому что `int` целиком помещается в `float`, а `float` целиком в `int` не поместится, что выведет ошибку типа).
>
> Если у переменной не инициализированно значение, то ей присваивается дефолтное для данного типа значение:
> * `int` -> 0
> * `float` -> 0f
> * `double` -> 0d
> * `decimal` -> 0m
> * `string` -> ""
> * `boolean` -> false

Пример
```
func main() {
	let a : int;  // ОК (имеет дефолтное значение 0)
	let b : int = 10;  // ОК
	let c : double = 10f;  // ОК
	let d : string = "Hello world!";  // ОК
	let e : string = 10;  // ОШИБКА ТИПА
	let f : int = 10.2f;  // ОШИБКА ТИПА
}
```
Переменные можно использовать в выражениях
> [!IMPORTANT]
> Тип переменной, используемой в выражении, должен явно или неявно совпадать требуемому типу выражения.
Пример
```
func main() {
	let a : int = 10;
	let b : int = a;  // ОК
	let c : string = a;  // ОШИБКА ТИПА
}
```

# Операторы
Операторы в `Coddy` делятся на:
* [Арифметические](#арифметические-операторы)
* [Логические](#логические-операторы)
* [Присвоения](#операторы-присвоения)
* [Тернарные](#тернарные-операторы)
* [Побитовые сдвиги](#операторы-побитовых-сдвигов)
> [!WARNING]
> Операторы могут быть использованы только с явно или неявно равными типами выражений. Каждый тип может быть использован только в опеределённой группе операторов, заданных языком.

### Арифметические операторы
* `+` (Плюс)
* `-` (Минус)
* `*` (Умножить)
* `/` (Разделить)
* `%` (Остаток от деления)

### Логические операторы
* `>` (Больше)
* `>=` (Больше или равно)
* `<` (Меньше)
* `<=` (Меньше или равно)
* `||` (ИЛИ)
* `&&` (И)
* `==` (Равно)
* `!=` (Не равно)
* `!` (Логическое отрицание)

### Операторы присвоения
* `=` (Равно)
* `+=` (Прибавить к текущему значению выражение)
* `-=` (Отнять от текущего значения выражение)
* `*=` (Умножить текущее значение на выражение)
* `/=` (Разделиь текущее значение на выражение)
* `%=` (Присвоить остаток от деления текущего значения к выражению)
* `++` (Инкремент/Прибавить 1)
* `--` (Декремент/Отнять 1)

### Тернарные операторы
Тернарный оператор образуется из **условного выражения**, последующих знака `?`, выражения при _истинном условном выражении_, символа `:` и выражения при _ложном условном выражении_.
> [!IMPORTANT]
> Тернарные операторы применимы только к выражениям.

### Операторы побитовых сдвигов
* `<<` (Побитовый сдвиг влево)
* `>>` (Побитовый сдвиг вправо)
* `>>>` (Беззнаковый/логический побитовый сдвиг вправо)

Пример
```Coddy
func main() {
	let a : string = 1 == 1 ? "YES" : "NO";  // Сохранит значение "YES"
}
```

# Блоки
Блоками кода называется весь код, заключённый в фигурные скобки `{}`.

# Ветвление
Ветвление строится на двух ключевых словах: `if` ("если", требует обязательного условного выражения) и `else` ("иначе", условное выражение не указывается). Ветвление строится с помощью ключевого слова `if`, последующего условного выражения, заключённого в круглые скобки `()` и блока кода, который выполнится при _истинном_ условном выражении. После основного условного оператора может идти неосновной исключающий условный оператор `else`, который требует только последующего блока кода, который выполнится, если основное условное выражение (описанное в `if`) будет _ложным_.

Пример
```Coddy
func main() {
	let a : int = 10;
	if (a > 10) {  // ЛОЖЬ (выполнится код в else)
	  a = 0;
	}
	else {
	  a = -1;
	}
}
```

# Циклы
* [while](#цикл-while)
* [do/while](#цикл-dowhile)
* [for](#цикл-for)

### Цикл while
Тело цикла выполняется до тех пор, пока истино условное выражение (сначала идёт проверка на истинность условного выражения, а затем выполнение блока кода при _истинном_ условном выражении). Цикл `while` строится с помощью ключевого слова `while`, последующего условного выражения, заключённого в круглые скобки `()` и блока кода, который будет выполнятся пока _истино_ условное выражение.

Пример
```Coddy
func main() {
	let a : int;
	while (a < 10) {
	  a++;
	}
}
```

### Цикл do/while
Тело цикла выполняется до тех пор, пока истино условное выражение (сначала выполняется тело цикла, а затем идёт проверка на истинность условного выражения. Если условное выражение истинно, то выполнение тела продолжается). Цикл `do/while` строится с помощью ключевого слова `do`, блока кода, ключевого слова `while`, последующего условного выражения, заключённого в круглые скобки `()` и символом окончания строки `;`.

Пример
```Coddy
func main() {
	let a : int;
	do {
	  a++;
	} while (a < 10);
}
```

### Цикл for
Цикл `for` имеет свой встроенный индексатор, тело цикла выполняется до тех пор, пока истино условное выражение (сначала идёт объявление индексатора, затем проверка на истинность условного выражения. Если условное выражение _истинно_, то выполняется тело цикла, после чего индексатор меняет своё значение, в соответсвтии с заданным пользователем параметром изменения). Цикл `for` строится с помощью ключевого слова `for`, последующими свойствами цикла и блоком кода. Свойства цикла `for` строятся с помощью объявления индексатора (`<имя_индексатора> : <тип> = <выражение>`), разделительного символа `:`, условного выражения, разделительного символа `:` и параметр изменения индексатора (`<имя_индексатора> <оператор_присвоения> <выражение>`). Свойства цикла заключены в круглые скобки `()`.

Пример
```Coddy
func main() {
	let a : int;
	for (i : int = 0 : i < 10 : i++) {
	  a = i * i;
	}
}
```

# Switch/case
`Coddy` с версии **v0.10.3** поддерживает оператор `switch`. `switch` объявляется с помощью ключевого слова `switch`, последующим именем переменной/поля в круглых скобках `()` и блоком **case-операторов**. Case-оператор объявляются с помощью выражения, с которым будет сравниваться переданная в `switch` переменная, токен `=>` и оператор (или блок кода). Если необходимо задать значение по умолчанию, то вместо выражения в **case-операторе** необходимо использовать `_`.

Пример
```Coddy
func main() {
	print("Enter integer number: ");
	let a : int = to_int(input());
	
	switch (a) {
		2 => println(a * 2);
		10 => println(a * a * 10);
		_ => println("Other");
	}
}
```

# Функции
* [void-функции (не возвращающие значений)](#свойства-void-функций)
* [type-функции (возвращающие значения)](#свойства-type-функций)
* [Встроенные](#встроенные-функции)

Функции объявляются с помощью ключевого слова `func`, последующим именем функции, аргументами функции (`<имя_аргумента> : <тип_аргумента>`), перечисленными через запятую `,`, заключенными в круглых скобках `()`, а также последующим блоком кода (void-функция). Для объявления type-функции после имени функции необходимо указать символ разделения `:`, а также тип возвращаемого значения. Для возврата значений из функции необходимо использовать оператор `return` с последующим возвращаемым выражением.
> [!IMPORTANT]
> Тип возвращаемого значения функции и тип значения, описанного после `return` должны быть явно или неявно равны.
> В void-функциях разрешено использование `return`, но при условии отсутствия возвращаемого выражения после `return`.

Вызов функции строится с помощью имени функции и последующим перечислением через запятую `,` аргументов функции (при наличии), заключенным в круглых скобках `()`.
> [!IMPORTANT]
> Типы перечисляемых аргументов и ожидаемых аргументов функции должны быть явно или неявно равны.
> Количество перечисляемых и ожидаемых аргументов должно совпадать.

### Свойства void-функций
* Не обязательно могут иметь операторы `return`
* Не могут использоваться в выражениях (только в виде отдельной команды)

Пример void-функции
```Coddy
let a : int;
func b () {  // Декларация
  a = 10;
}

func main() => b();  // Вызов
```

### Свойства type-функций
* Обязательно должны иметь операторы `return` с описываемым выражением
* Могут использоваться как в выражениях, так и в виде отдельной команды
* Должны иметь операторы `return` для каждого случая

Пример type-функции
```Coddy
func sum : int(a : int, b : int) {  // Декларация
  return a + b;
}

func main() {
	let a : int = sum(1, 2);  // Использование. Сохранит 3
}
```

> [!CAUTION]
> Транслятор из `Coddy` в `C#` автоматически генерирует метод `__Main__()`, который является точкой входа в программу. Функции на `Coddy` нельзя называть `__Main__()`, так как в таком случае после трнасляции возникнет 2 одинаковых по названию метода `__Main__()`, что приведёт к ошибке компиляции.

### Встроенные функции
* `print(message)` - функция, которая выводит любой переданный объект в консоль без перевода на следующую строку
* `println(message)` - функция, которая выводит любой переданный объект в консоль с переводом в конце на следующую строку
* `input()` - функция, которая возвращает введённое пользователем в консоль сообщения
* `to_int(object)` - функция, которая конвертирует переданный объект в целое число
* `to_float(object)` - функция, которая конвертирует переданный объект в число с плавающей точкой
* `to_double(object)` - функция, которая конвертирует переданный объект в число с плавающей точкой двойной точности
* `to_decimal(object)` - функция, которая конвертирует переданный объект в вещественное число
* `to_string(object)` - функция, которая возвращает строковое представление переданного объекта
* `to_boolean(strBoolean)` - функция, которая возвращает конвертированное переданное строковое представление логического типа в логический тип
* `len(object)` - функция, которая возвращает длину переданного объекта (массива или строки)
* `type(object)` - функция, которая возвращает строковое представление типа переданного объекта

# Массивы
Массивы объявляются как и обычные переменные, но после типа ставятся квадратные скобки `[]`, внутри которых по желанию можно указать длину массива (по умолчанию длина равна 0). По желанию можно проинициализировать массив с помощью знака `=` и в квадратных скобках `[]` через запятую `,` указать элементы массива, указав после квадратных скобок `[]` тип элементов (через символ `:`).

> [!IMPORTANT]
> Если Вы указали размер массива и решили проинициализировать его, то количество указанных Вами элементов должно совпадать с заданным Вами размером.

Пример
```Coddy
func main() {
	let array : int[];  // ОК
	let array2 : int[4];  // ОК
	let array3 : int[] = [1, 2, 3, 4] : int;  // ОК
	let array4 : int[4] = [1, 2, 3] : int;  // ОШИБКА (кол-во переданных элементов не совпадает с заданным размером)
	let array5 : int[4] = [1, 2, 3, 4];  // ОШИБКА (не указан тип после элементов массива)
}
```

> [!NOTE]
> Массивы также можно указывать в качестве возвращаемых значений или аргументов для функций и методов, а также использовать их в аргументах конструктора.

# ООП (неполное)
`Coddy` поддерживает неполную систему ООП, а именно: [классы](#классы), [поля/методы классов](#поля-и-методы), [контекст `this`](#контекст-this), [конструкторы](#конструкторы), [создание экземпляров классов](#экземпляры), [вызов полей/методов из экземпляров](#вызовы-членов-класса), [статика](#статика), [интерфейсы](#интерфейсы), [наследование](#наследование), [свойства](#свойства), [вызов базовых членов](#вызов-бызовых-членов).

### Классы
Классы объявляются с помощью ключевого слова `class`, последующего имени класса и блоком кода класса.

> [!CAUTION]
> Транслятор из `Coddy` в `C#` автоматически генерирует класс `__Program__`, который является базовым классом всей программы. Классы на `Coddy` нельзя называть `__Program__`, так как в таком случае после трнасляции возникнет 2 одинаковых по названию класса `__Program__`, что приведёт к ошибке компиляции.

Пример
```Coddy
class Test {
  
}
```

### Поля и методы
Внутри класса могут существовать только _поля_ и _методы_, которые в совокупности называются _члены класса_. Каждый член класса имеет свой модификатор доступа `private` или `public`. Поля и методы декларируются также, как переменные и функции, но с использовнием модификатора доступа в начале.

Пример
```Coddy
class Person {
  private let age : int = 15;

  public func print {
    return println("Hello world!");
  }
}
```

### Контекст `this`
К членам данного класса внутри него самого возможно обращаться как с помощью имени члена, так и с помощью контекста `this`. Для обращения к любому полю/методу изнутри исходного класса необходимо использовать ключевое слово `this`, оператор точка `.` и интересующий член класса.

Пример
```Coddy
class Person {
  private let name : string = "Nikita";
  private let age : int = 15;

  public func getName : string() {
    return name;  // Без контекста this
  }

  public func getAge : int() {
    return this.age;  // Контекст this
  }
}
```

### Конструкторы
Для того чтобы задать необходимые значения полям класса при создании экземпляра можно использовать **конструкторы**. Для использования конструктора необходимо использовать ключевое слово `constructor` (как отдельный член класса, но без модификатора досутпа), последующее перечисление аргументов конструктора, заключённых в круглые скобки `()` и блок конструктора.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }
}
```

> [!IMPORTANT]
> Типы перечисляемых аргументов и ожидаемых аргументов конструктора должны быть явно или неявно равны.
> Количество перечисляемых и ожидаемых аргументов должно совпадать.

### Экземпляры
Экземпляр класса `<класс>` - переменная, с типом `<класс>` и выражением в виде `new <класс>(<аргументы_конструктора>)`. Экземпляры классов можно создавать как в основной программе, так и внутри других классов. Экземпляры класса создаются только в том случае, если класс не является статическим.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }
}

func main() {
	let person : Person = new Person("Alex", 15);
}
```

### Вызовы членов класса
Члены класса вызываются из экземпляра с помощью оператора точка `.`. Члены класса из экземпляра можно вызвать только в том случае, если данный член помечен модификатором досутпа `public`. Вызвы можно использовать в выражениях, если итоговое полученное поле/метод можно использовать в выражениях.

Пример
```Coddy
class Person {
  private let name : string;
  private let age : int;

  constructor (name : string, age : int) {
    this.name = name;
    this.age = age;
  }

  public func getAge : int() {
    return this.age;
  }

  public func printName() {
    println(this.name);
  }
}

func main() {
	let person : Person = new Person("Alex", 15);
	let age : int = person.getAge();  // ОК
	let name : string = person.name;  // ОШИБКА УРОВНЯ ЗАЩИТЫ
	person.printName();  // ОК
}
```

### Статика
`Coddy` с версии **v0.3.0** поддерживает статические классы, методы и поля. Статические классы не могут иметь нестатических полей и методов, а также конструкторов. Статические методы могут существовать в любых классах, но внутри таких методов можно использовать только статические методы и поля того же класса (без контекста `this`). Доступ к статическим полям и методам осуществляется с помощью имени класса, оператора точка `.` и именем члена класса.

Пример
```Coddy
static class Person {
  public static let Name : string = "Alex";
  public static func GetAge : int () {
    return 15;
  }
}

func main() {
	println(Person.Name);
	println(Person.GetAge());
	Person.Name = "Nikita";
	println(Person.Name);
}
```

### Интерфейсы
`Coddy` с версии **v0.9.0** поддерживает объявление интерфейсов. Интерфейсы могут объявляться как внутри классов, так и за их пределами. Интерфейсы объявляются с помощью ключевого слова `interface`, последующим именем интерфейса и перечислением методов интерфейса в фигурных скобках `{}`. Методы интерфейсов не должны иметь реализации и модификаторов.

Пример
```Coddy
interface IValue {
  func getValue : int();
}

class Value {
  public interface IValue2 {
    func getValue : string();
  }
}
```

### Наследование
`Coddy` с версии **v0.9.0** поддерживает наследование классов и интерфейсов. Интерфейсы могут наследовать только другие интерфейсы в неограниченном количестве, а классы могут наследовать максимум только один другой класс (в цепочке наследования он должен стоять первым) и неограниченное количество интерфейсов. Наследование осуществляется с помощью специального оператора `::` после имени класса/интерфейса для указания наследования, а также последовательно идущие через запятую объекты для наследования.

Пример:
```Coddy
interface IA {...}
interface IB :: IA {...}

class A :: IA, IB {...}
class B :: A {...}
```

Для наследования классов были добавлены новые модификаторы для методов: `ovrd` и `virt`, которые нужны для переопеределения методов. Методы с одним из таких модификаторов не могут быть статическими. Модификатор `virt` объявляет метод с базовой реализацией, которую разрешено изменять в дочерних классах данному классу с помощью модификатора `ovrd` из дочернего класса.

Пример
```Coddy
class A {
  public virtual func toString : string() {
    return "Object";
  }
}

class B :: A {}
class C :: A {
  public ovrd func toString : string() {
    return "Hello, world!";
  }
}

func main() {
	B b = new B();
	println(b.toString());  // Выведет "Object"
	C c = new C();
	println(c.toString());  // Выведет "Hello, world!"
}
```

### Свойства
`Coddy` с версии **v0.10.1** поддерживает свойства `getter` и `setter` для полей классов. Свойства перечисляются через запятую в скобках после имени поля.

> [!NOTE]
> Порядок свойств не имеет значения - вы можете указать `(getter, setter)` или `(setter, getter)` и это не будет иметь разницы.

Пример
```Coddy
class Test {
	public let field(getter) : int;
	public let field2(getter, setter) : int;
}

func main() {
	let test : Test = new Test();
	println(test.field);	// ОК
	test.field = 10;	// ОШИБКА (не указано свойство setter)
}
```

### Вызов базовых членов
`Coddy` с версии **v0.10.2** поддерживает вызов базовых членов в производных классах. Вызов базовых членов включет в себя обращение к полям, методам и вызов базовых конструкторов с помощью ключевого слова `parent`. Обращение к полям и методам осуществляется с помощью оператора точка `.` после `parent`, а вызов базового конструктора осуществляется с помощью разделительного символа `:` перед блоком кода конструктора производного класса, последующим ключевым словом `parent` и перечислением аргументов конструктора в круглых скобках `()`.

Пример
```Coddy
class A {
	public let field : int;

	constructor(name : string) {
		println("Hello, " + name + "!");
	}
}

class B :: A {
	constructor() : parent("Nikita") {
		println(parent.field);
	}
}

func main() {
	let test : B = new B();	// Выведет "Hello, Nikita!" и на следующей строке "0"
}
```

# Константы
`Coddy` с версии **v0.10.4** поддерживает константные поля и переменные. Для объявления константы надо указать модификатор `const` в круглых скобках `()` после ключевого слова `let`.

> [!WARNING]
> Константые поля не могут иметь модификатор `static`.

Пример
```Coddy
static class Math {
  public let(const) pi : double = 3.14159265358979323846d;
}

let(const) e : double = 2.71828182845904523536d;
```

# Перечисления
`Coddy` с версии **v0.8.0** поддерживает перечисления (enum). Перечисления объявляются с помощью ключевого слова `enum` и блока кода с перечислением элементов через запятую `,`. Получение элемента из перечисления осуществляется с помощью имени перечисления, оператора точка `.` и последующим именем элемента.

Пример
```Coddy
enum Color {
  Red, Blue, Green
}

func main() {
	let color : Color = Color.Red;
}
```

```Coddy
class Color {
  public enum ColorEnum {
    Red, Blue, Green
  }
}

func main() {
	let color : Color.ColorEnum = Color.ColorEnum.Red;
}
```

> [!NOTE]
> Перечисления можно объявлять в основной программе или внутри класса (не могут быть статическими).

# Импорт библиотек
`Coddy` с версии **v0.4.0** поддерживает импорт библиотек. Импорт библиотек осуществляется с помощью ключевого слова `include` и строкового выражения пути к библиотечному файлу. Считываются только классы и перечисления из библиотечного файла.
`Coddy` с версии **v0.5.0** поддерживает импорт нативных библиотек (*.dll и *.cs).

> [!IMPORTANT]
> `Coddy` поддерживает в качестве библиотечных файлов только файлы с расширением *.cd, *.dll, *.cs.

> [!CAUTION]
> Импорт нативных библиотек может работать нестабильно. `Quantum Games Studio` просит обращаться в [поддержку](#поддержка) для выявления и последующего устранения ошибок.

Пример
```Coddy
include "math.cd";

func main() => println(Math.sqrt(25));  // Встроенный метод статического класса math
```

# Импорт файлов
`Coddy` с версии **v0.9.0** поддерживает импорт файлов на языке `Coddy` (*.cd). Импорт файлов позволяет загружать в основную программу классы и перечисления из указанного файла. Импорт файлов осуществляется с помощью ключевого слова `use` и последующим строковым выражением (полный путь к интересующему файлу с указанием расширения).

Пример

test.cd:
```Coddy
static class Test {
  public static func print(message : string) {
    println(message);
  }
}
```

example.cd
```Coddy
use "C:/User/User/Desktop/test.cd";

func main() => Test.print("Hello, world!");  // Выведет в консоль "Hello, world"
```

# Лямбда выражения
`Coddy` с версии **v0.10.2** поддерживает лямбда выражения. Лямбда выражения можно применять к телам функций, методов и конструкторов с помощью специального токена `=>` и последующим выражением.

Пример
```Coddy
func main() => hello("Nikita");	// Выведет Hello, Nikita!

func hello(name : string) => println("Hello, " + name + "!");
```

# Исключения
`Coddy` с версии **v0.10.0** поддерживает выброс и обработку исключений. Выброс исключения осуществляется с помощью ключевого слова `throw` и последующим созданием экземпляра встроенных классов, на подобии `Exception`, в котором при желании можно указать сообщение ошибки. Обработка исключений осуществляется с помощью конструкции `try/catch/finally`. Возможно выбрасывать и обрабатывать любые исключения, поддерживающиеся в `C#`.

Пример
```Coddy
func validateIndex(index : int) {
  if (index < 0) throw new Exception("Индекс не может быть отрицательным");
}

func main() {
	try {
	  index : int = -1;
	  validateIndex(index);
	} catch (ex : Exception) {
	  println("Было вызывано исключение");
	}
}
```

> [!NOTE]
> Конструкция `finally` является необязательной и может не указываться. Конструкция `try` требует любую из конструкций `catch` или `finally`.

# Generics обобщения
`Coddy` с версии **v0.10.0** поддерживает обобщения. Обобщения указываются в треугольных скобках `<>` после имени класса или метода.

Пример
```Coddy
class MyList<T> {  // Объявление обобщённого типа
  private let _values : T[];

  constructor() {
    _values = [] : T;
  }

  public func add(value : T) {
    let newValues : T[len(_values) + 1];
		for (i : int : i < len(_values) : i++) newValues[i] = _values[i];
		newValues[length()] = value;

		_values = newValues;
  }

  public func get : T (index : int) {
    if (index >= len(_values) || index < 0) throw new Exception("Индекс вышел за пределы списка: " + to_string(index));

		return _values[index];
  }
}

func main() {
	let list : MyList<int> = new MyList<int>();
}
```

# Поддержка
`Quantum Games Studio` предоставляет возможность задавать вопросы и обращаться за просьбой об устранении ошибок в проекте `Coddy` напрямую на [почту](https://mail.google.com/mail/?view=cm&fs=1&to=coddy.language.project@gmail.com) или в [телеграм](https://t.me/SamirShef).

Изначальная идея к названию проекта была `Бутерброд++` (источник: [Burrittoss](https://t.me/Burrittosss)).

Язык будет дорабатываться и обрастать новыми возможностями, совсем скоро будет очередное обновление...
